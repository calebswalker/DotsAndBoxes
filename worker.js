(()=>{"use strict";var e,t;function n({u:e,v:t}){return t<e?`${t} ${e}`:`${e} ${t}`}function s(e){const t=e.split(" "),n=Number(t[0]),s=Number(t[1]);return{u:Math.min(n,s),v:Math.max(n,s)}}!function(e){e[e.None=0]="None",e[e.Player1=1]="Player1",e[e.Player2=-1]="Player2"}(e||(e={})),function(e){e.Player1="#dd4124",e.Player2="#2958db"}(t||(t={}));class i{constructor(e){this.adjacencyLists=new Map,this.vertexCount=0,this.edgeCount=0,e&&(e.adjacencyLists.forEach(((e,t)=>{const n=new Set;e.forEach((e=>n.add(e))),this.adjacencyLists.set(t,n)})),this.vertexCount=e.vertexCount,this.edgeCount=e.edgeCount)}addVertex(e){this.adjacencyLists.has(e)||(this.adjacencyLists.set(e,new Set),this.vertexCount++)}addEdge(e,t){const n=this.adjacencyLists.get(e),s=this.adjacencyLists.get(t);if(!n)throw new Error(`No vertex ${e} exists`);if(!s)throw new Error(`No vertex ${t} exists`);if(e==t)throw new Error("Cannot add a self-edge");this.hasEdge(e,t)||(n.add(t),s.add(e),this.edgeCount++)}getEdge(e,t){if(!this.hasEdge(e,t))throw new Error(`Edge ${e}, ${t} doesn't exist`);return{u:Math.min(e,t),v:Math.max(e,t)}}getEdgeIfExists(e,t){if(this.hasEdge(e,t))return{u:Math.min(e,t),v:Math.max(e,t)}}hasEdge(e,t){const n=this.adjacencyLists.get(e),s=this.adjacencyLists.get(t);return null!=n&&null!=s&&n.has(t)&&s.has(e)}removeEdgeIfExists(e,t){if(this.hasEdge(e,t))return this.removeEdge(e,t)}removeEdge(e,t){const n=this.adjacencyLists.get(e),s=this.adjacencyLists.get(t);if(!this.hasEdge(e,t)||!n||!s)throw new Error(`Edge ${e}-${t} doesn't exist`);return n.delete(t),s.delete(e),this.edgeCount--,e<t?{u:e,v:t}:{u:t,v:e}}neighbors(e){const t=this.adjacencyLists.get(e);if(!t)throw new Error(`${e} is not a vertex in the graph`);return t}degree(e){const t=this.adjacencyLists.get(e);if(!t)throw new Error(`${e} is not a vertex in the graph`);return t.size}vertices(){return this.adjacencyLists.keys()}*edges(){for(const[e,t]of this.adjacencyLists.entries())for(const n of t)e>n||(yield{u:e,v:n})}numberOfEdges(){return this.edgeCount}numberOfVertices(){return this.vertexCount}*bfs(e){const t=[e],n=new Set;for(;0!=t.length;){const e=t.shift();if(null!=e&&!n.has(e)){n.add(e);for(const s of this.neighbors(e))n.has(s)||t.unshift(s);yield e}}}*dfs(e){const t=[e],n=new Set;for(;0!=t.length;){const e=t.pop();if(null!=e&&!n.has(e)){n.add(e);for(const s of this.neighbors(e))n.has(s)||t.push(s);yield e}}}}class o extends i{constructor(e){if(super(e),this.innerNodes=new Set,this.outerNodes=new Set,this.degreeOneInnerNodes=new Set,this.rowFactor=10,this.edgeHash=0n,e)this.innerNodes=new Set(e.innerNodes),this.outerNodes=new Set(e.outerNodes),this.rowFactor=e.rowFactor;else{for(;this.rowFactor<Math.max(4,6);)this.rowFactor*=10;for(let e=1;e<=4;e++)for(let t=1;t<=6;t++){const n=e*this.rowFactor+t;this.innerNodes.add(n),this.addVertex(n)}for(let e=1;e<=6;e++){const t=0*this.rowFactor+e;this.outerNodes.add(t),this.addVertex(t)}for(let e=1;e<=6;e++){const t=5*this.rowFactor+e;this.outerNodes.add(t),this.addVertex(t)}for(let e=1;e<=4;e++){const t=e*this.rowFactor+0;this.outerNodes.add(t),this.addVertex(t)}for(let e=1;e<=4;e++){const t=e*this.rowFactor+7;this.outerNodes.add(t),this.addVertex(t)}for(const e of this.vertices()){if(this.outerNodes.has(e))continue;const t=Math.floor(e/this.rowFactor),n=e%this.rowFactor;[[t-1,n],[t,n+1],[t+1,n],[t,n-1]].forEach((([t,n])=>{const s=t*this.rowFactor+n;this.addEdge(e,s)}))}}this.edgeHash=this.computeHash(),this.degreeOneInnerNodes=this.computeDegreeOneInnerNodes()}computeDegreeOneInnerNodes(){const e=new Set;for(const t of this.vertices())this.isInnerNode(t)&&1==this.degree(t)&&e.add(t);return e}getDegreeOneInnerNodes(){return new Set(this.degreeOneInnerNodes)}getInnerNodes(){return[...this.innerNodes]}isInnerNode(e){return this.innerNodes.has(e)}isOuterNode(e){return this.outerNodes.has(e)}computeHash(){let e=0n;for(let t=o.EdgeIndex.length-1;t>=0;t--){const{u:n,v:s}=o.EdgeIndex[t];e<<=1n,e+=this.hasEdge(n,s)?1n:0n}return e}getEdgeHash(){return this.edgeHash}updateDegreeOneSet(e){this.isOuterNode(e)||(1==this.degree(e)?this.degreeOneInnerNodes.add(e):this.degreeOneInnerNodes.delete(e))}addEdge(e,t){super.addEdge(e,t);const n=1n<<BigInt(o.getEdgeIndex(e,t));this.edgeHash=this.edgeHash|n,this.updateDegreeOneSet(e),this.updateDegreeOneSet(t)}removeEdge(e,t){const n=super.removeEdge(e,t),s=1n<<BigInt(o.getEdgeIndex(e,t));return this.edgeHash=this.edgeHash&~s,this.updateDegreeOneSet(e),this.updateDegreeOneSet(t),n}static fromHash(e){const t=new o;let n=0;for(;e>0n;){if(!(1n&e)){const e=o.EdgeIndex[n];t.removeEdgeIfExists(e.u,e.v)}e>>=1n,n++}return t}static getEdgeIndex(e,t){return t<e?o.getEdgeIndex(t,e):t-e==10?6*Math.floor((e-1)/10)+(e-1)%10:30+7*(Math.floor(e/10)-1)+e%10}}function r(e){return Array.isArray(e)?e:[e]}o.EmptyHash=288230376151711743n,o.EdgeIndex=[{u:1,v:11},{u:2,v:12},{u:3,v:13},{u:4,v:14},{u:5,v:15},{u:6,v:16},{u:11,v:21},{u:12,v:22},{u:13,v:23},{u:14,v:24},{u:15,v:25},{u:16,v:26},{u:21,v:31},{u:22,v:32},{u:23,v:33},{u:24,v:34},{u:25,v:35},{u:26,v:36},{u:31,v:41},{u:32,v:42},{u:33,v:43},{u:34,v:44},{u:35,v:45},{u:36,v:46},{u:41,v:51},{u:42,v:52},{u:43,v:53},{u:44,v:54},{u:45,v:55},{u:46,v:56},{u:10,v:11},{u:11,v:12},{u:12,v:13},{u:13,v:14},{u:14,v:15},{u:15,v:16},{u:16,v:17},{u:20,v:21},{u:21,v:22},{u:22,v:23},{u:23,v:24},{u:24,v:25},{u:25,v:26},{u:26,v:27},{u:30,v:31},{u:31,v:32},{u:32,v:33},{u:33,v:34},{u:34,v:35},{u:35,v:36},{u:36,v:37},{u:40,v:41},{u:41,v:42},{u:42,v:43},{u:43,v:44},{u:44,v:45},{u:45,v:46},{u:46,v:47}];class a extends o{constructor(t){if(super(t),this.boxOwners=new Map,this.currentPlayer=e.Player1,this.player1Score=0,this.player2Score=0,this.moveLog=[],t)this.boxOwners=new Map(t.boxOwners),this.currentPlayer=t.currentPlayer,this.moveLog=[...t.moveLog],this.player1Score=t.player1Score,this.player2Score=t.player2Score;else for(const t of this.getInnerNodes())this.boxOwners.set(t,e.None)}static cleanFromGameGraph(t,n=e.Player1){const s=new a;for(const{u:e,v:n}of[...s.edges()])t.hasEdge(e,n)||s.removeEdge(e,n);return s.currentPlayer=n,s}getPlayer1Score(){return this.player1Score}getPlayer2Score(){return this.player2Score}getScoreDifference(){return this.player1Score-this.player2Score}getCurrentPlayer(){return this.currentPlayer}isPlayer1sTurn(){return this.getCurrentPlayer()==e.Player1}getUnclaimedEdges(){return[...this.edges()]}getUnclaimedEdgesThatDoNotCreateABox(){return[...this.edges()].filter((({u:e,v:t})=>(this.isOuterNode(e)||this.degree(e)>2)&&(this.isOuterNode(t)||this.degree(t)>2)))}getEdgesThatEitherCaptureABoxOrDoNotCreateABox(e){const t=[...this.edges()],n=t.filter((({u:e,v:t})=>this.isInnerNode(e)&&1==this.degree(e)||this.isInnerNode(t)&&1==this.degree(t)));if(e&&n.length>0)return n;const s=t.filter((({u:e,v:t})=>2!=this.degree(e)&&2!=this.degree(t)));return s.length>0?(n.push(...s),n):t}isEndGame(){for(const{u:e,v:t}of this.edges())if((this.isOuterNode(e)||this.degree(e)>2)&&(this.isOuterNode(t)||this.degree(t)>2))return!1;return!0}getBoxOwner(e){return this.boxOwners.get(e)}setBoxOwner(t,n){const s=this.boxOwners.get(t);if(null==s||s!=e.None&&n!=e.None)throw new Error(`Box ${t} either doesn't exist or is already taken`);s==e.Player1?this.player1Score--:s==e.Player2&&this.player2Score--,this.boxOwners.set(t,n),n==e.Player1?this.player1Score++:n==e.Player2&&this.player2Score++}*boxes(){for(const e of this.boxOwners.keys())yield e}*unownedBoxes(){for(const[t,n]of this.boxOwners)n==e.None&&(yield t)}*boxesAndOwners(){for(const[e,t]of this.boxOwners)yield[e,t]}makeMove(e){const t=[];let n=!1;for(const s of function*(e){if(Array.isArray(e))for(const t of e)yield t;else yield e}(e)){if(n)throw new Error("Move continues past completing no more boxes");const e=this.makeSingleMove(s);t.push(e),e.completedBox||(n=!0)}return t}makeSingleMove({u:e,v:t}){if(!this.hasEdge(e,t))throw new Error(`Illegal move: ${e}-${t}`);const n=this.removeEdge(e,t);let s=this.moveLog.length>0?this.moveLog[this.moveLog.length-1]:void 0;s&&s.player==this.currentPlayer||(s={player:this.currentPlayer,moves:[]},this.moveLog.push(s)),s.moves.push(n);let i=!1;this.isInnerNode(e)&&0==this.degree(e)&&(this.setBoxOwner(e,this.currentPlayer),i=!0),this.isInnerNode(t)&&0==this.degree(t)&&(this.setBoxOwner(t,this.currentPlayer),i=!0);const o={move:n,completedBox:i};return i||(this.currentPlayer=-this.currentPlayer),o}getWinner(){if(!this.isGameOver())return;let t=this.getScoreDifference();return t>0?e.Player1:t<0?e.Player2:e.None}isGameOver(){return 0==this.numberOfEdges()}revertMove(e){const t=r(e);for(let e=t.length-1;e>=0;e--){s=t[e],null==(n=this.revertSingleMove())||null==s||n.u==s.u&&n.v==s.v||n.u==s.v&&(n.v,s.u)}var n,s}revertEntirePlayerMove(){const e=this.moveLog.length;for(;this.moveLog.length==e;)this.revertSingleMove()}revertSingleMove(){const t=this.moveLog.pop();if(!t)throw new Error("No move to revert");const n=t.moves.pop();if(!n)throw new Error("no single move to remove");this.addEdge(n.u,n.v);const s=this.getBoxOwner(n.u),i=this.getBoxOwner(n.v);return null!=s&&s!=e.None&&this.setBoxOwner(n.u,e.None),null!=i&&i!=e.None&&this.setBoxOwner(n.v,e.None),this.currentPlayer=t.player,t.moves.length>0&&this.moveLog.push(t),n}moveLogLength(){return this.moveLog.length}getAllLegalMoves(){const e=new Set,t=new Set,i=[];for(const s of this.edges()){const o=n(s);if(t.has(o))continue;const r=this.degree(s.u),a=this.degree(s.v),h=this.isInnerNode(s.u)&&1==r?s.u:this.isInnerNode(s.v)&&1==a?s.v:void 0;if(null!=h){const o=[];let r=h;for(const e of this.dfs(h))if(e!=h){if(null!=r&&o.push({u:Math.min(r,e),v:Math.max(r,e)}),this.degree(e)>2)break;r=e}if(1==o.length){const i=n(s);e.add(i),t.add(i);continue}o.forEach((s=>{const i=n(s);e.delete(i),t.add(i)}));const a={fullCapture:o},l=2==this.degree(r),u=1==this.degree(r);if(l&&o.length>=2){const e=o.slice(0,-2);e.push(o[o.length-1]),a.handout=e}else if(u&&o.length>=5){const e=o.slice(0,-3);e.push(o[o.length-2]),a.handout=e}i.push(a)}else e.add(n(s))}if(i.length>=2)return i.map((({fullCapture:e})=>e));if(1==i.length){const e=[],t=i[0];e.push(t.fullCapture);const n=t.handout;return null!=n&&e.push(n),e}const o=[];for(const t of e)o.push(s(t));return o}getAllPlayedMoves(){return this.moveLog.flatMap((e=>e.moves))}getFullHash(){const e=BigInt(this.getScoreDifference()+24<<1|(this.isPlayer1sTurn()?0:1));return this.getEdgeHash()<<8n|e}}function h(e,t,n){const s=e.indexOf(t);if(s<0)throw new Error(n??"Element is not part of array");e.splice(s,1)}function l(e){const t=e.vertices.length;return t>=4||t>=2&&null!=e.tailJoint}a.BoxIndex=[11,12,13,14,15,16,21,22,23,24,25,26,31,32,33,34,35,36,41,42,43,44,45,46];class u{constructor(e){this.dotsAndBoxesGraph=new a(e)}classifyVertices(){const e=new Set,t=new Set,n=new Set,s=new Set,i=new Map;for(const o of this.dotsAndBoxesGraph.vertices()){const r=this.dotsAndBoxesGraph.neighbors(o),a=r.size;if(0!=a)if(this.dotsAndBoxesGraph.isOuterNode(o))t.add(o);else if(1==a)e.add(o);else if(2==a)n.add(o);else{if(3!=a&&4!=a)throw new Error(`Impossible degree ${a} at vertex ${o}`);s.add(o),i.set(o,new Set(r))}}return{oneVertices:e,outerVertices:t,twoVertices:n,jointVertices:s,jointNeighbors:i}}computeCapturableComponents(e,t,n,s,i){if(0==e.size)return[];const o=[],r=new Map,a=(o,r,a)=>{const h=[];let l;const u=[o],d=new Set(a);for(;0!=u.length;){const o=u.pop();if(null==o||d.has(o))continue;d.add(o);const a=i.get(o),c=this.dotsAndBoxesGraph.neighbors(o),g=a??c;for(const e of g)d.has(e)||u.push(e);let m=s.has(o);if(r&&!m&&c.size>=3&&null==a&&(m=!0,s.add(o),i.set(o,new Set(g))),m||this.dotsAndBoxesGraph.isOuterNode(o)){l=o,t.delete(o);break}h.push(o),e.delete(o),n.delete(o)}return{componentVertices:h,componentTailJoint:l}};for(const t of e){const{componentVertices:e,componentTailJoint:n}=a(t,!0),s={vertices:e,isCapturable:!0,isLoop:!1,headJoint:void 0,tailJoint:n};if(null!=s.tailJoint&&this.dotsAndBoxesGraph.isInnerNode(s.tailJoint)){const e=s.tailJoint;let t=r.get(e);null==t&&(t=[],r.set(e,t)),t.push(s)}o.push(s)}e.size;const u=(e,t)=>{let n;return n=(l(e)?1:0)-(l(t)?1:0),0==n&&(n=(null!=e.tailJoint&&s.has(e.tailJoint)?-1:0)-(null!=t.tailJoint&&s.has(t.tailJoint)?-1:0),0==n&&(n=e.vertices.length-t.vertices.length,0==n&&(n=(null==e.tailJoint?-1:0)-(null==t.tailJoint?-1:0)))),n};o.sort(u);const d=[];for(;0!=o.length;){const e=o.shift();if(null==e)throw Error();d.push(e);const t=e.tailJoint;if(null==t||this.dotsAndBoxesGraph.isOuterNode(t))continue;const l=e.vertices[e.vertices.length-1],c=r.get(t),g=i.get(t);if(null==l||null==c||null==g)throw new Error("adjacent stuff isn't valid");if(h(c,e,"Adjacent capturable component is not actually adjacent"),g.delete(l),!(g.size>2))if(s.delete(t),0!=c.length){if(1==c.length){const e=c[0],n=e.vertices[e.vertices.length-1];let s;if(e.vertices.push(t),g.forEach((e=>{n!=e&&(s=e)})),null==s)throw new Error("undefined starting neighbor");const{componentVertices:i,componentTailJoint:o}=a(s,!1,[t]);if(e.vertices.push(...i),e.tailJoint=o,null!=o&&this.dotsAndBoxesGraph.isInnerNode(o)){let t=r.get(o);null==t&&(t=[],r.set(o,t)),t.push(e)}}else if(2==c.length){const e=c[0],n=c[1];h(o,n,"adjacent capturable component is not in list"),e.vertices.push(t),e.vertices.push(...n.vertices.reverse()),e.tailJoint=void 0}o.sort(u)}else n.add(t)}return d}computeNonCapturableComponents(e,t,n){const s=[];for(const i of e){const o={vertices:[],isCapturable:!1,isLoop:!1,headJoint:i};for(const s of this.dotsAndBoxesGraph.dfs(i))if(s!=i){if(n.has(s)||this.dotsAndBoxesGraph.isOuterNode(s)){o.tailJoint=s,e.delete(s);break}o.vertices.push(s),t.delete(s)}e.delete(i),s.push(o)}e.size;for(const e of n){for(const i of this.dotsAndBoxesGraph.neighbors(e)){if(!t.has(i)&&!n.has(i))continue;const o={vertices:[],isCapturable:!1,headJoint:e,isLoop:!1},r=[i],a=new Set;for(;0!=r.length;){const s=r.pop();if(null!=s&&!a.has(s)){if(a.add(s),n.has(s)){o.tailJoint=s;break}o.vertices.push(s),t.delete(s);for(const t of this.dotsAndBoxesGraph.neighbors(s))a.has(t)||s==i&&t==e||r.push(t)}}s.push(o)}n.delete(e)}if(n.size,t.size>0&&(t.size%2!=0||t.size<4))throw new Error("invalid parity for generating loops");for(const e of t){const n={vertices:[],isCapturable:!1,isLoop:!0,headJoint:void 0,tailJoint:void 0};for(const s of this.dotsAndBoxesGraph.dfs(e))n.vertices.push(s),t.delete(s);s.push(n)}return t.size,s.sort(((e,t)=>e.vertices.length-t.vertices.length)),s}computeCurrentComponents(){const e=new Set,t=new Set,n=new Set,s=new Set,i=new Map;for(const o of this.dotsAndBoxesGraph.vertices()){const r=this.dotsAndBoxesGraph.neighbors(o),a=r.size;if(0!=a)if(this.dotsAndBoxesGraph.isOuterNode(o))t.add(o);else if(1==a)e.add(o);else if(2==a)n.add(o);else{if(3!=a&&4!=a)throw new Error(`Impossible degree ${a} at vertex ${o}`);s.add(o),i.set(o,new Set(r))}}const o=[],r=new Map,a=(o,r)=>{const a=[];let h;const l=[o],u=new Set(r);for(;0!=l.length;){const o=l.pop();if(null==o||u.has(o))continue;u.add(o);const r=i.get(o),d=r??this.dotsAndBoxesGraph.neighbors(o);for(const e of d)u.has(e)||l.push(e);const c=s.has(o);if(c||this.dotsAndBoxesGraph.isOuterNode(o)){h=o,t.delete(o),c&&null==r&&i.set(o,new Set(d));break}a.push(o),e.delete(o),n.delete(o)}return{componentVertices:a,componentTailJoint:h}};for(const t of e){const{componentVertices:e,componentTailJoint:n}=a(t),s={vertices:e,isCapturable:!0,isLoop:!1,headJoint:void 0,tailJoint:n};if(null!=s.tailJoint&&this.dotsAndBoxesGraph.isInnerNode(s.tailJoint)){const e=s.tailJoint;let t=r.get(e);null==t&&(t=[],r.set(e,t)),t.push(s)}o.push(s)}e.size;const u=(e,t)=>{let n;return n=(l(e)?1:0)-(l(t)?1:0),0==n&&(n=(null!=e.tailJoint&&s.has(e.tailJoint)?-1:0)-(null!=t.tailJoint&&s.has(t.tailJoint)?-1:0),0==n&&(n=e.vertices.length-t.vertices.length,0==n&&(n=(null==e.tailJoint?-1:0)-(null==t.tailJoint?-1:0)))),n};o.sort(u);const d=[];for(;0!=o.length;){const e=o.shift();if(null==e)throw Error();d.push(e);const t=e.tailJoint;if(null==t||this.dotsAndBoxesGraph.isOuterNode(t))continue;const l=e.vertices[e.vertices.length-1],c=r.get(t),g=i.get(t);if(null==l||null==c||null==g)throw new Error("adjacent stuff isn't valid");if(h(c,e,"Adjacent capturable component is not actually adjacent"),g.delete(l),!(g.size>2))if(s.delete(t),0!=c.length){if(1==c.length){const e=c[0],n=e.vertices[e.vertices.length-1];let s;if(e.vertices.push(t),g.forEach((e=>{n!=e&&(s=e)})),null==s)throw new Error("undefined starting neighbor");const{componentVertices:i,componentTailJoint:o}=a(s,[t]);if(e.vertices.push(...i),e.tailJoint=o,null!=o&&this.dotsAndBoxesGraph.isInnerNode(o)){let t=r.get(o);null==t&&(t=[],r.set(o,t)),t.push(e)}}else if(2==c.length){const e=c[0],n=c[1];h(o,n,"adjacent capturable component is not in list"),e.vertices.push(t),e.vertices.push(...n.vertices.reverse()),e.tailJoint=void 0}o.sort(u)}else n.add(t)}const c=[];for(const e of t){const i={vertices:[],isCapturable:!1,isLoop:!1,headJoint:e};for(const o of this.dotsAndBoxesGraph.dfs(e))if(o!=e){if(s.has(o)||this.dotsAndBoxesGraph.isOuterNode(o)){i.tailJoint=o,t.delete(o);break}i.vertices.push(o),n.delete(o)}t.delete(e),c.push(i)}t.size;for(const e of s){for(const t of this.dotsAndBoxesGraph.neighbors(e)){if(!n.has(t)&&!s.has(t))continue;const i={vertices:[],isCapturable:!1,headJoint:e,isLoop:!1},o=[t],r=new Set;for(;0!=o.length;){const a=o.pop();if(null!=a&&!r.has(a)){if(r.add(a),s.has(a)){i.tailJoint=a;break}i.vertices.push(a),n.delete(a);for(const n of this.dotsAndBoxesGraph.neighbors(a))r.has(n)||a==t&&n==e||o.push(n)}}c.push(i)}s.delete(e)}if(s.size,n.size>0&&(n.size%2!=0||n.size<4))throw new Error("invalid parity for generating loops");for(const e of n){const t={vertices:[],isCapturable:!1,isLoop:!0,headJoint:void 0,tailJoint:void 0};for(const s of this.dotsAndBoxesGraph.dfs(e))t.vertices.push(s),n.delete(s);c.push(t)}return n.size,c.sort(((e,t)=>e.vertices.length-t.vertices.length)),{nonCapturableComponents:c,capturableComponentSequence:d}}computeAllCurrentComponents(){const{oneVertices:e,twoVertices:t,jointVertices:n,outerVertices:s,jointNeighbors:i}=this.classifyVertices();return{capturableComponentSequence:this.computeCapturableComponents(e,s,t,n,i),nonCapturableComponents:this.computeNonCapturableComponents(s,t,n)}}splitCapturableComponent(e){const t=e.vertices,n=t.length,s=[],i=[];let o;const r=null!=e.tailJoint?n-2:n-4;for(let e=0;e<r;e++)s.push(this.dotsAndBoxesGraph.getEdge(t[e],t[e+1]));for(let e=Math.max(r,0);e<n-1;e++)i.push(this.dotsAndBoxesGraph.getEdge(t[e],t[e+1]));return null!=e.tailJoint&&i.push(this.dotsAndBoxesGraph.getEdge(t[n-1],e.tailJoint)),l(e)&&(o=null!=e.tailJoint?this.dotsAndBoxesGraph.getEdge(t[n-1],e.tailJoint):this.dotsAndBoxesGraph.getEdge(t[n-3],t[n-2])),{intersection:s,fullCaptureSuffix:i,handoutSuffix:o}}getNumberOfBoxesCapturedInFullCapture(e){const t=e.vertices.length;return null!=e.tailJoint?t:t-1}getFullCaptureMove(e){const t=e.vertices,n=t.length,s=[];for(let e=0;e<n-1;e++)s.push(this.dotsAndBoxesGraph.getEdge(t[e],t[e+1]));return null!=e.tailJoint&&s.push(this.dotsAndBoxesGraph.getEdge(t[n-1],e.tailJoint)),s}getNonCapturableComponentOpenMove(e){const t=e.vertices,n=t.length;if(e.isLoop)return this.dotsAndBoxesGraph.getEdge(t[0],t[1]);if(0==n){if(null==e.tailJoint)throw new Error("Component of length 0 with insufficient virtual vertices found");return this.dotsAndBoxesGraph.getEdge(e.headJoint,e.tailJoint)}return 1==n||null!=e.tailJoint&&e.headJoint==e.tailJoint?this.dotsAndBoxesGraph.getEdge(e.headJoint,t[0]):this.dotsAndBoxesGraph.getEdge(t[0],t[1])}evaluate(e=!1){let t=this.dotsAndBoxesGraph.getScoreDifference();if(e){const e=this.dotsAndBoxesGraph.isPlayer1sTurn()?1:-1;for(const n of this.dotsAndBoxesGraph.unownedBoxes())t+=e}return t}isPlayer1sTurn(){return this.dotsAndBoxesGraph.isPlayer1sTurn()}getStateHash(e,t,n){let s=this.dotsAndBoxesGraph.getFullHash();const i=Math.min(Math.max(e,-24),24)+48,o=Math.min(Math.max(t,-24),24)+48;return((s<<6n|BigInt(i))<<6n|BigInt(o))<<8n|n}execute(e){this.dotsAndBoxesGraph.makeMove(e)}revert(e){this.dotsAndBoxesGraph.revertMove(e)}getWinner(){return this.dotsAndBoxesGraph.getWinner()}isGameOver(){return this.dotsAndBoxesGraph.isGameOver()}getNormalActions(){return this.dotsAndBoxesGraph.getUnclaimedEdgesThatDoNotCreateABox()}getAllActions(){return this.dotsAndBoxesGraph.getUnclaimedEdges()}getCapturableMovesFromCapturableVertices(){const e=this.dotsAndBoxesGraph.getDegreeOneInnerNodes();return 0==e.size?[]:this.computeCapturableComponents(e,new Set,new Set,new Set,new Map)}isEndGame(){return this.dotsAndBoxesGraph.isEndGame()}}class d{constructor(e){this.cachedStates=new Map,this.cacheHit=0,this.cacheCount=0,this.depth=0n,this.endgameMinimax=new u(e)}getOptimalAction(){this.depth=0n,this.cacheHit=0,this.cacheCount=0,this.cachedStates.clear();const{bestAction:e,value:t}=this.getValue(-1/0,1/0);return{bestAction:e,value:t}}getCacheHitRate(){return this.cacheHit/Math.max(this.cacheCount,1)}getValue(e,t,n){this.cacheCount++,this.depth++;const s=this.endgameMinimax.getStateHash(e,t,this.depth),i=this.cachedStates.get(s);if(null!=i)return this.cacheHit++,this.depth--,i;let o;const r=this.endgameMinimax.isPlayer1sTurn();return o=n||this.endgameMinimax.isEndGame()?r?this.maxEndgameValue(e,t):this.minEndgameValue(e,t):r?this.maxNormalWithCapturesValue(e,t):this.minNormalWithCapturesValue(e,t),this.cachedStates.set(s,o),this.depth--,o}getEndgameValue(e,t){this.cacheCount++;const n=this.endgameMinimax.getStateHash(e,t,this.depth),s=this.cachedStates.get(n);if(null!=s)return this.cacheHit++,s;let i;return i=this.endgameMinimax.isPlayer1sTurn()?this.maxEndgameValue(e,t):this.minEndgameValue(e,t),this.cachedStates.set(n,i),i}maxEndgameValue(e,t){if(!this.endgameMinimax.isPlayer1sTurn())throw new Error("Wrong Player");const{capturableComponentSequence:n,nonCapturableComponents:s}=this.endgameMinimax.computeAllCurrentComponents();if(0==s.length)return{value:this.endgameMinimax.evaluate(!0),bestAction:n.map((e=>this.endgameMinimax.getFullCaptureMove(e)))};let i,o=-1/0;const r=[];for(let e=0;e<n.length-1;e++){const t=n[e],s=this.endgameMinimax.getFullCaptureMove(t);r.push(s),this.endgameMinimax.execute(s)}let a,h=!1;const l=n[n.length-1];if(null!=l){const{intersection:n,handoutSuffix:s,fullCaptureSuffix:u}=this.endgameMinimax.splitCapturableComponent(l);if(n.length>0&&(r.push(n),this.endgameMinimax.execute(n)),null!=s){this.endgameMinimax.execute(s);const{value:n}=this.getValue(e,t,!0);this.endgameMinimax.revert(s),(null==i||n>o)&&(i=[s],o=n),o>=t?h=!0:e=Math.max(e,o)}a=u}if(!h){null!=a&&this.endgameMinimax.execute(a);for(const n of s){const s=this.endgameMinimax.getNonCapturableComponentOpenMove(n);this.endgameMinimax.execute(s);const{value:r}=this.getValue(e,t,!0);if(this.endgameMinimax.revert(s),(null==i||r>o)&&(i=null!=a?[a,s]:[s],o=r),o>=t)break;e=Math.max(e,o)}null!=a&&this.endgameMinimax.revert(a)}for(let e=r.length-1;e>=0;e--)this.endgameMinimax.revert(r[e]);const u=r;return null!=i&&u.push(...i),{value:o,bestAction:u}}minEndgameValue(e,t){if(this.endgameMinimax.isPlayer1sTurn())throw new Error("Wrong Player");const{capturableComponentSequence:n,nonCapturableComponents:s}=this.endgameMinimax.computeAllCurrentComponents();if(0==s.length)return{value:this.endgameMinimax.evaluate(!0),bestAction:n.map((e=>this.endgameMinimax.getFullCaptureMove(e)))};let i,o=1/0;const r=[];for(let e=0;e<n.length-1;e++){const t=n[e],s=this.endgameMinimax.getFullCaptureMove(t);r.push(s),this.endgameMinimax.execute(s)}let a,h=!1;const l=n[n.length-1];if(null!=l){const{intersection:n,handoutSuffix:s,fullCaptureSuffix:u}=this.endgameMinimax.splitCapturableComponent(l);if(n.length>0&&(r.push(n),this.endgameMinimax.execute(n)),null!=s){this.endgameMinimax.execute(s);const{value:n}=this.getValue(e,t,!0);this.endgameMinimax.revert(s),(null==i||n<o)&&(i=[s],o=n),o<=e?h=!0:t=Math.min(t,o)}a=u}if(!h){null!=a&&this.endgameMinimax.execute(a);for(const n of s){const s=this.endgameMinimax.getNonCapturableComponentOpenMove(n);this.endgameMinimax.execute(s);const{value:r}=this.getValue(e,t,!0);if(this.endgameMinimax.revert(s),(null==i||r<o)&&(i=null!=a?[a,s]:[s],o=r),o<=e)break;t=Math.min(t,o)}null!=a&&this.endgameMinimax.revert(a)}for(let e=r.length-1;e>=0;e--)this.endgameMinimax.revert(r[e]);const u=r;return null!=i&&u.push(...i),{value:o,bestAction:u}}maxNormalValue(e,t){let n=-1/0;const s=this.endgameMinimax.getNormalActions();let i=s[0];for(let o=0;o<s.length;o++){const r=s[o];this.endgameMinimax.execute(r);const{value:a}=this.getValue(e,t);if(this.endgameMinimax.revert(r),(null==i||a>n||a==1/0)&&(i=r,n=a),n>=t)break;e=Math.max(e,n)}return{value:n,bestAction:[i]}}minNormalValue(e,t){let n=1/0;const s=this.endgameMinimax.getNormalActions();let i=s[0];for(let o=0;o<s.length;o++){const r=s[o];this.endgameMinimax.execute(r);const{value:a}=this.getValue(e,t);if(this.endgameMinimax.revert(r),(null==i||a<n||a==-1/0)&&(i=r,n=a),n<=e)break;t=Math.min(t,n)}return{value:n,bestAction:[i]}}maxNormalWithCapturesValue(e,t){if(!this.endgameMinimax.isPlayer1sTurn())throw new Error("Wrong Player");const n=this.endgameMinimax.getCapturableMovesFromCapturableVertices();let s,i=-1/0;const o=[];for(let e=0;e<n.length-1;e++){const t=n[e],s=this.endgameMinimax.getFullCaptureMove(t);o.push(s),this.endgameMinimax.execute(s)}let r,a=!1;const h=n[n.length-1];if(null!=h){const{intersection:n,handoutSuffix:l,fullCaptureSuffix:u}=this.endgameMinimax.splitCapturableComponent(h);if(n.length>0&&(o.push(n),this.endgameMinimax.execute(n)),null!=l){this.endgameMinimax.execute(l);const{value:n}=this.getValue(e,t);this.endgameMinimax.revert(l),(null==s||n>i)&&(s=[l],i=n),i>=t?a=!0:e=Math.max(e,i)}r=u}if(!a){null!=r&&this.endgameMinimax.execute(r);for(const n of this.endgameMinimax.getNormalActions()){this.endgameMinimax.execute(n);const{value:o}=this.getValue(e,t);if(this.endgameMinimax.revert(n),(null==s||o>i)&&(s=null!=r?[r,n]:[n],i=o),i>=t)break;e=Math.max(e,i)}null!=r&&this.endgameMinimax.revert(r)}for(let e=o.length-1;e>=0;e--)this.endgameMinimax.revert(o[e]);const l=o;return null!=s&&l.push(...s),{value:i,bestAction:l}}minNormalWithCapturesValue(e,t){if(this.endgameMinimax.isPlayer1sTurn())throw new Error("Wrong Player");const n=this.endgameMinimax.getCapturableMovesFromCapturableVertices();let s,i=1/0;const o=[];for(let e=0;e<n.length-1;e++){const t=n[e],s=this.endgameMinimax.getFullCaptureMove(t);o.push(s),this.endgameMinimax.execute(s)}let r,a=!1;const h=n[n.length-1];if(null!=h){const{intersection:n,handoutSuffix:l,fullCaptureSuffix:u}=this.endgameMinimax.splitCapturableComponent(h);if(n.length>0&&(o.push(n),this.endgameMinimax.execute(n)),null!=l){this.endgameMinimax.execute(l);const{value:n}=this.getValue(e,t);this.endgameMinimax.revert(l),(null==s||n<i)&&(s=[l],i=n),i<=e?a=!0:t=Math.min(t,i)}r=u}if(!a){null!=r&&this.endgameMinimax.execute(r);for(const n of this.endgameMinimax.getNormalActions()){this.endgameMinimax.execute(n);const{value:o}=this.getValue(e,t);if(this.endgameMinimax.revert(n),(null==s||o<i)&&(s=null!=r?[r,n]:[n],i=o),i<=e)break;t=Math.min(t,i)}null!=r&&this.endgameMinimax.revert(r)}for(let e=o.length-1;e>=0;e--)this.endgameMinimax.revert(o[e]);const l=o;return null!=s&&l.push(...s),{value:i,bestAction:l}}}const c=Math.random;class g{getOptimalAction(e){const t=e.getActions();let n;return t.sort((()=>c()-.5)),n=t.pop(),{action:n}}}class m{constructor(e){this.game=e,this.getActions=()=>this.game.getEdgesThatEitherCaptureABoxOrDoNotCreateABox(!0),this.execute=()=>{},this.revert=()=>{},this.isPlayer1sTurn=()=>!0,this.isGameOver=()=>!1,this.getWinner=()=>{},this.evaluate=()=>0}}console.log("WORKER LIVE"),self.onmessage=e=>{const t=e.data,{moves:n}=t.game,s=(t.currentPlayer,t.settings);let i,o;const h=new a;for(const e of n)h.makeMove(e);const l=h.getUnclaimedEdgesThatDoNotCreateABox();if(console.log("Safe Edge Count",l.length),l.length>(s?.threshold??24)){const e=(new g).getOptimalAction(new m(h));i=e.action,console.log("Random Move:",e)}else{const e=new d(h),t=performance.now(),n=e.getOptimalAction(),s=performance.now()-t;i=function(e){return e.reduce(((e,t)=>e.concat(r(t))),[])}(n.bestAction),o=n.value,console.log("Endgame Move:",i,"Value:",o,"Time (ms):",s,"Cache Hit Rate:",e.getCacheHitRate())}self.postMessage({move:i})}})();